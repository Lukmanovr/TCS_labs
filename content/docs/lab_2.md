---
title: Lab 2 - FSA
type: docs
weight: 2
BookToC: true
---
# **Lab Session #2**

# **Agenda**

- Finite State Automaton 
- Exercises on Finite State Automaton (FSA)

## **Finite State Automaton**  

A finite state automaton (FSA) is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The state of an FSA determines its behavior, and it can change its state in response to inputs.

An FSA is defined by a set of states, a set of inputs, a set of transitions, and a set of accepting states. The states are the possible states of the FSA. The inputs are the symbols that the FSA can read. The transitions are the rules that determine how the FSA changes its state in response to an input. The accepting states are the states in which the FSA accepts an input.

An FSA can be used to model a wide variety of problems. For example, an FSA can be used to model a vending machine. The states of the FSA can represent the different states of the vending machine, such as "empty", "has coins", "has selected item", and "dispensing item". The inputs of the FSA can represent the different actions that the user can take, such as "insert coin", "select item", and "press button". The transitions of the FSA can represent the rules that determine how the vending machine changes its state in response to an input. For example, if the user inserts a coin and then selects an item, the vending machine will change its state from "has coins" to "dispensing item".

FSAs are a powerful tool for modeling and solving problems. They are used in a wide variety of applications, including:

- Vending machines
- Traffic lights
- Elevators
- Calculators
- Computer programs
- Natural language processing
- Speech recognition
- Machine translation

FSAs are a versatile and powerful tool that can be used to solve a wide variety of problems. They are a valuable tool for anyone who works in computer science, engineering, or mathematics.

![placeholdertext](/images/lab2/1.png)

#### **Formal Definition**  

A deterministic finite automaton M is a 5-tuple, (Q, {{< katex >}} Σ {{< /katex >}}, δ, {{< katex >}} q_0 {{< /katex >}}, F), consisting
of
- a finite set of states Q
- a finite set of input symbols called the alphabet Σ 
- a transition function δ : Q × {{< katex >}} Σ {{< /katex >}} → Q 
- an initial or start state {{< katex >}} q_0 {{< /katex >}} ∈ Q 
- a set of accept states F ∈ Q

#### **Simple Problem**  

What string cannot be generated by the finite state automaton below?

<img src="/images/lab2/2.png" width="400px" height="400px">

## **Exercises**  

### **Part I**

Build complete FSAs that recognize the following languages:

Let {{< katex >}} Σ {{< /katex >}} be the alphabet {{< katex >}} Σ {{< /katex >}} = {0, 1}

1. {{< katex >}} L_1 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} starts with 1 };
{{< expand >}}
   ![placeholdertext](/images/lab2/3.png)
{{< /expand >}}
2. {{< katex >}} L_2 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} does not begin with 1 };
{{< expand >}}
   ![placeholdertext](/images/lab2/4.png)
{{< /expand >}}
3. {{< katex >}} L_3 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} | any 0 in{{< katex >}} x {{< /katex >}} is followed by at least a 1 }. Strings example: 010111, 1111, 01110111011.
{{< expand >}}
   ![placeholdertext](/images/lab2/5.png)
{{< /expand >}}
4. {{< katex >}} L_4 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} ends with 00};
{{< expand >}}
   ![placeholdertext](/images/lab2/6.png)
{{< /expand >}}
5. {{< katex >}} L_5 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} contains exactly 3 zeros };
{{< expand >}}
   ![placeholdertext](/images/lab2/7.png)
{{< /expand >}}

### **Part II**

Build complete FSAs that recognize the following languages: Let {{< katex >}} Σ {{< /katex >}} be the alphabet {{< katex >}} Σ {{< /katex >}} = {a, b}

6. {{< katex >}} L_6 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} | every a in{{< katex >}} x {{< /katex >}} (if there are any) is followed immediately by bb }.
{{< expand >}}
   ![placeholdertext](/images/lab2/8.png)
{{< /expand >}}
7. {{< katex >}} L_7 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} ends with b and does not contain the substring aa }.
{{< expand >}}
   ![placeholdertext](/images/lab2/9.png)
{{< /expand >}}
8. {{< katex >}} L_8 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} contains the substring abbaab };
{{< expand >}}
   ![placeholdertext](/images/lab2/10.png)
{{< /expand >}}
9. {{< katex >}} L_9 {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} has an even number of a’s and an even number of b’s };
{{< expand >}}
   ![placeholdertext](/images/lab2/11.png)
{{< /expand >}}

### **Part III**

Build complete FSAs accepting the following languages over the alphabet {{< katex >}} Σ {{< /katex >}} = {0, 1}
10. {{< katex >}} L_a {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} |{{< katex >}} x {{< /katex >}} is a binary representation of an integer divisible by 5, and it begins with 1 };
{{< expand >}}
   ![placeholdertext](/images/lab2/12.png)
{{< /expand >}}
11. {{< katex >}} L_b {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} | |x| ≥ 2 {{< katex >}} ^ {{< /katex >}} final two symbols are the same };
{{< expand >}}
.
    ![placeholdertext](/images/lab2/13.png)
{{< /expand >}}
12. Build a complete FSA accepting the following language over the alphabet {{< katex >}} Σ {{< /katex >}} = {a,b,c}

{{< katex >}} L_c {{< /katex >}} = {{{< katex >}} x {{< /katex >}} ∈ {{< katex >}} Σ^* {{< /katex >}} | the substring abc in{{< katex >}} x {{< /katex >}} occurs an odd number of times }.
{{< expand >}}
   ![placeholdertext](/images/lab2/14.png)
{{< /expand >}}

## **Homework**

![placeholdertext](/images/lab2/15.png)

The figure is a marble toy. A marble is dropped at A or B.
Levers {{< katex >}} x_1 {{< /katex >}}, {{< katex >}} x_2 {{< /katex >}}, 
and {{< katex >}} x_3 {{< /katex >}} cause the marble to fall either to the left
of to the right. Whenever a marble encounters a lever, it causes 
the lever to reverse after the marble passes, so the next marble 
will take the opposite branch.

Model this toy by a complete FSA. Let the inputs A and B represent 
the input into which the marble is dropped. Let acceptance correspond 
to the marble exiting at D; nonacceptance represents a marble exiting at C.
